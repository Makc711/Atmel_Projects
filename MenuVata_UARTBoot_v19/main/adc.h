#ifndef ADC_H_
#define ADC_H_
//-------------------------------------------------------------------------
//							Подключаемые библиотеки
//-------------------------------------------------------------------------
#include "main.h"

#ifndef F_CPU
#warning "F_CPU not defined for "adc.h""
//#define F_CPU 16000000UL // Указываем частоту тактирования микроконтроллера в Гц
#endif

// Настройки АЦП:
#define CHANNELS_ADC 0b00000111 // Указываем, с какими каналами будет работать АЦП 
					 // двоичное число: биты, установленные в 1, соответствуют подключенным каналам АЦП
#define UREF_ADC     ADC_UREF_INT // Выбор ИОН (ADC_UREF_OUT, ADC_UREF_VCC, ADC_UREF_INT)
#define NMEASURE 500 // Количество измерений АЦП для вычисления усредненного значения [1;65535]

//-------------------------------------------------------------------------
//							Объявление псевдонимов
//-------------------------------------------------------------------------
//			  7		  6		  5		 4		3	   2	  1	     0
//ADMUX = [ REFS1 | REFS0 | ADLAR |	 -	 | MUX3 | MUX2 | MUX1 | MUX0 ]

//======Выбор ИОН=========================================================
#define ADC_UREF_OUT	(0<<REFS1)|(0<<REFS0) // ИОН на входе AREF
#define ADC_UREF_VCC	(0<<REFS1)|(1<<REFS0) // ИОН - Uпит (к входу AREF можно подключить фильтрующий конденсатор)
#define ADC_UREF_INT	(1<<REFS1)|(1<<REFS0) // Внутренний ИОН (см. значение внутреннего ИОН в даташите)(к входу AREF можно подключить фильтрующий конденсатор)
//=========================================================================

//======Определяем как результат преобразования запишется в регистры ADCL и ADCH==============================
#define CHOOSE_BIT_ADCL (0<<ADLAR) /*В ADCL записываются 8 младших битов (8 LSB), а два старших (2 MSB) в ADCH.
	 _______________				 Это удобно, если используется 10-ти разрядный АЦП и чтение осуществляется из переменной ADCW.
	 ___ADLAR = 0___
			 15		14	   13     12	 11	    10	    9	   8
   ADCH = [   -  |   -  |   -  |   -  |   -  |   -  | ADC9 | ADC8 ]
			  7		 6	    5      4	  3	     2	    1	   0
   ADCL = [ ADC7 | ADC6 | ADC5 | ADC4 | ADC3 | ADC2 | ADC1 | ADC0 ]  							*/	
#define CHOOSE_BIT_ADCH	(1<<ADLAR) /*В ADCH записываются 8 старших битов (8 MSB), а два младших (2 LSB) в ADCL. 
     _______________                 Это удобно, если для точности измерений достаточно 8-ми старших бит преобразования.
	 ___ADLAR = 1___
			 15		14	   13     12	 11	    10	    9	   8
   ADCH = [ ADC9 | ADC8 | ADC7 | ADC6 | ADC5 | ADC4 | ADC3 | ADC2 ]
 			  7		 6	    5      4	  3	     2	    1	   0
   ADCL = [ ADC1 | ADC0 |   -  |   -  |   -  |   -  |   -  |   -  ]  							*/
//============================================================================================================						

//======Выбор канала АЦП=======
#define ADC_CH_0		0
#define ADC_CH_1		1
#define ADC_CH_2		2
#define ADC_CH_3		3
#define ADC_CH_4		4
#define ADC_CH_5		5
#define ADC_CH_6		6
#define ADC_CH_7		7
//=============================

//=========================================================================
//							Прототипы функций
//=========================================================================
uint16_t adc_data(uint8_t chan); // Получить результат АЦП [0;1023]
//-------------------------------------------------------------------------
//	Функция получения данных из АЦП.
//
//	Возвращает значение:
//
//		adc_data(ADC_CH_x) - Значение АЦП [0;1023]
//		chan = [ADC_CH_0;ADC_CH_7] в зависимости от используемого канала
//-------------------------------------------------------------------------

#endif /* ADC_H_ */