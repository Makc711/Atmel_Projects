#include "usart.h"
//----------------------------------------
uint8_t byteRX; // Принятый байт по USART
char bf[20];
//----------------------------------------
INIT(7){ // Инициализация USART
	#include <util/setbaud.h> // Библиотека для расчета значения UBRR_VALUE
	// Зададим скорость работы USART (ubrr)
	UBRR0H = UBRRH_VALUE; // Записать старшую часть числа ubrr в регистр UBRRH
	UBRR0L = UBRRL_VALUE; // Записать младшую часть числа ubrr в регистр UBRRL

	#if USE_2X // Если требуется удвоение скорости для устойчивой работы USART
	UCSR0A |= (1<<U2X); // Удвоение скорости работы по USART (Пригождается лишь когда работаешь на медленных кварцах, вроде часового)
	#else
	UCSR0A &= ~(1<<U2X);
	#endif
	UCSR0B |= (1<<TXEN); // Включаем передачу данных по USART
	#if ONLY_OUT == 0
	UCSR0B |= (1<<RXEN)|(1<<RXCIE); // Включаем прием данных по USART и разрешаем прерывание при окончании приема байта данных
	#endif
	
	UCSR0C |= (1<<UCSZ1)|(1<<UCSZ0); // 8-бит посылка (UCSZ1=1 и UCSZ0=1)
	//		     |(1<<USBS0); // 2 стоп-бита (USBS0=1), без контроля четности (UPM1=0 и UPM0=0), ассинхронный режим (UMSEL=0)
}
//----------------------------------------
void USART_Transmit_byte(uint8_t data){ // Отправить 1 байт данных по USART
	while ( !(UCSR0A & (1<<UDRE0)) ); // Ожидание опустошения регистра данных на передачу
	UDR0 = data; // Начало передачи данных
}
//----------------------------------------
void USART_Transmit_word(uint16_t data){ // Отправить слово (2 байта) по USART
	USART_Transmit_byte(data>>8); // Отправить старший байт слова по USART
	USART_Transmit_byte((uint8_t) data); // Отправить младший байт слова по USART
}
//----------------------------------------
void USART_Transmit_dword(uint32_t data){ // Отправить двойное слово (4 байта) по USART
	USART_Transmit_byte(data>>24); // Отправить самый старший байт слова по USART
	USART_Transmit_byte(data>>16); // Отправить байт слова помладше по USART
	USART_Transmit_byte(data>>8); // Отправить байт слова еще младше по USART
	USART_Transmit_byte((uint8_t) data); // Отправить самый младший байт слова по USART
}
//----------------------------------------
void USART_Transmit_msg(uint8_t *msg, uint16_t msgSize){ // Отправить сообщение размером msgSize байт по USART
	for (uint16_t i=0; i<msgSize; i++){
		USART_Transmit_byte(msg[i]); // Отправляем байты массива
	}
}
//----------------------------------------
void USART_Transmit_string(const char *s){ // Отправить строку данных по USART
	while (*s) USART_Transmit_byte(*s++); // Пока символы строки не закончатся, отправлять их по USART
}
//----------------------------------------
void (*Goto_Boot)(void); // Функция запуска Bootloader'а
//----------------------------------------
//___________ВЕКТОРЫ ПРЕРЫВАНИЙ___________
//========================================
ISR(USART0_RX_vect){ // Завершение приема данных по USART
	byteRX = UDR0;
//----------------------------------------
//____________Вызов Bootloader'а__________
//----------------------------------------
	if (byteRX == 0x7F){ // Если пришел код 0x7F (код команды 'DEL' кодировки ASCII)
//##### Перед тем как переходить в Bootloader, надо сбросить всю работу на портах
		cli(); // Запрещаем глобальные прерывания
		hcms_puts("Обновление ПО"); // Вывод строки на дисплей
		WriteStringMC14489("UPd", H_Alloff); // Отправить строку данных и точку
		LED_TEN_OFF; // Выключаем светодиод ТЭН
		LED_START_OFF; // Выключаем светодиод ПУСК
		TIMSK &= ~(1<<TOIE2); // Запрещаем прерывания при переполнении таймера-счетчика 2
		OCR1B = 0; // Сбрасываем ШИМ (МОТОР)
		PORT(PORT_PWMTEN) |= _BV(PIN_PWMTEN); // Подаем 1 (гасим ТЭН)
//#####
		Goto_Boot = (void(*)())Boot_Address;  // Инициализация указателя
		Goto_Boot();  // Переход на начало секции Bootloader'а
	}
//----------------------------------------
	
}
//========================================