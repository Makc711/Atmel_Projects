#include "adc.h" // Библиотека АЦП

//-------------------------------------------------------------------------
//							Инициализация переменных
//-------------------------------------------------------------------------
uint32_t adc_sumresult[8] = {0,0,0,0,0,0,0,0};  // Обнуляем 8 значений [0:7] АЦП (сумма результатов измерения АЦП)
volatile uint16_t adc_result[8] = {0,0,0,0,0,0,0,0};  // Обнуляем 8 значений [0:7] АЦП (Среднее арифметическое нескольких измерений АЦП)
uint8_t channel = 0; // Канал, с которым работает АЦП в данный момент
uint8_t ch[8]; // Каналы, с которыми будет работать АЦП
uint16_t nresult[8] = {0,0,0,0,0,0,0,0}; // Счетчик прерываний АЦП для каждого канала

//-------------------------------------------------------------------------
//	Функция инициализации АЦП.
//
//	Принимает аргументы:
//
//		uref - Выбор ИОН. (ADC_UREF_OUT, ADC_UREF_VCC, ADC_UREF_INT)
//		ch_byte - Двоичное число: биты, установленные в 1, соответствуют подключенным каналам АЦП
//
//-------------------------------------------------------------------------
INIT(7){ // Инициализация АЦП
	uint8_t ch_byte = CHANNELS_ADC; // Байт "рабочих" каналов АЦП
	for (uint8_t i=0; i<8; i++) {
		ch[i] = ch_byte & 1; // Побитно умножаем байт каналов на маску, чтобы определить, с какими каналами работаем
		ch_byte = ch_byte>>1; // Сдвигаем байт вправо на 1 бит (переходим к проверке следующего бита)
	}
	while (ch[channel] == 0){ // Пока не появится рабочий канал
		channel = (channel + 1) % 8; // Остаток от деления на 8. Увеличиваем канал на 1.
	// Если ни один канал не подключен, здесь будет зависание программы
	}
	ADMUX = ((UREF_ADC|CHOOSE_BIT_ADCL)&0xF0) + channel; // Выбираем первый из рабочих каналов АЦП
/*			  7		  6		  5		 4		3	   2	  1	     0
//ADMUX = [ REFS1 | REFS0 | ADLAR |	 -	 | MUX3 | MUX2 | MUX1 | MUX0 ]
			   7	  6		    5	       4	  3	     2	     1	     0
  ADCSRA = [ ADEN | ADSC | ADFR(ADATE) | ADIF | ADIE | ADPS2 | ADPS1 | ADPS0 ]	
     7-------ADEN. Разрешение АЦП
		     0 – АЦП выключен
		     1 – АЦП включен
     6--------------ADSC. Запуск преобразования (в режиме однократного преобразования)
					0 – преобразование завершено
					1 – начать преобразование
     5---------------------ADFR(ADATE). Выбор режима работы АЦП
						   0 – режим однократного преобразования
						   1 – режим непрерывного преобразования
     4----------------------------ADIF. Флаг прерывания от АЦП. Бит устанавливается, когда преобразование закончено.
     3------------------------------------------ADIE. Разрешение прерывания от АЦП
										        0 – прерывание запрещено
										        1 – прерывание разрешено
										        Прерывание от АЦП генерируется (если разрешено) по завершении преобразования.
     2:0-----------------------------------------------ADPS2:ADPS0. Тактовая частота АЦП
*/
	ADCSRA |= (1<<ADEN)|(1<<ADIE);

// Для стабильной работы АЦП необходимо тактировать частотой в пределах 50 кГц - 200 кГц
		 if((F_CPU >=150000) & (F_CPU < 300000)) { //F_ADC=(75;150)kHz
			ADCSRA |= (1<<ADPS0); // делим F_CPU/2
		}
	else if((F_CPU >=300000) & (F_CPU < 600000)) { //F_ADC=(75;150)kHz
			ADCSRA |= (1<<ADPS1); // делим F_CPU/4
		}
	else if((F_CPU >= 600000) & (F_CPU < 1200000)) { //F_ADC=(75;150)kHz
			ADCSRA |= (1<<ADPS1)|(1<<ADPS0); // делим F_CPU/8
		}
	else if((F_CPU >= 1200000) & (F_CPU < 2400000)) { //F_ADC=(75;150)kHz
			ADCSRA |= (1<<ADPS2); // делим F_CPU/16
		}
	else if((F_CPU >= 2400000) & (F_CPU < 4800000)) { //F_ADC=(75;150)kHz
			ADCSRA |= (1<<ADPS2)|(1<<ADPS0); // делим F_CPU/32
		}
	else if((F_CPU >= 4800000) & (F_CPU < 9600000)) { //F_ADC=(75;150)kHz
			ADCSRA |= (1<<ADPS2)|(1<<ADPS1); // делим F_CPU/64
		}
	else if(F_CPU >= 9600000) { //F_ADC=(75;200)kHz F_CPU < 25,6 MHz!!!
			ADCSRA |= (1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0); // делим F_CPU/128
		}
		
	ADCSRA |= (1<<ADSC); // Запуск преобразования
}

//-------------------------------------------------------------------------
//	Функция получения данных из АЦП.
//
//	Возвращает значение:
//
//		adc_data(ADC_CH_x) - Значение АЦП [0;1023]
//		chan=[ADC_CH_0;ADC_CH_7] в зависимости от используемого канала
//-------------------------------------------------------------------------
uint16_t adc_data(uint8_t chan) { // Получить результат АЦП
		return(adc_result[chan]);		
}

//-------------------------------------------------------------------------
//					Функция прерывания ADC после преобразования
//-------------------------------------------------------------------------
ISR(ADC_vect) {
//	adc_sumresult[channel]=ADCW; // Записываем в переменную adc_result значение АЦП
	uint8_t adlow;
	adlow = ADCL; // read low first !!
	adc_sumresult[channel] += (ADCH<<8) | adlow; // Записываем в переменную adc_sumresult значение АЦП (сумма нескольких измерений АЦП)
	nresult[channel]++; // Считаем количество измерений для каждого канала
	if (nresult[channel] == NMEASURE){
		nresult[channel] = 0; // Обнуляем счетчик
		adc_result[channel] = adc_sumresult[channel] / NMEASURE; // Среднее арифметическое нескольких измерений
		adc_sumresult[channel] = 0; // Обнуляем
	}
		
	channel = (channel + 1) %8; // Остаток от деления на 8. Увеличиваем канал на 1.	
	while (ch[channel] == 0){
		channel = (channel + 1) % 8; // Остаток от деления на 8. Увеличиваем канал на 1.
	}
	ADMUX = (ADMUX & 0xF0) + channel; // устанавливаем работу с этим каналом
	ADCSRA |= (1<<ADSC); // Запуск преобразования
}