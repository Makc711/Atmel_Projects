#include "1wire.h"
//----------------------------------------
uint8_t ONE_wire_Init(void){ // Инициализация шины 1-wire. Возвращает 1 если присутствует устройство на шине, иначе 0.
	uint8_t reply1wire; // Счетчик - для ожидания ответа от устройства на шине
	uint8_t stektemp = SREG; // Сохраним значение стека
	cli(); // Запретим глобальные прерывания
	ONEWIRE_0; // Установить 0 на шине 1-wire
	_delay_us(485); // Задержка как минимум на 480 микросекунд для инициализации устройства
	ONEWIRE_1; // Установить 1 на шине 1-wire
	_delay_us(2); // Время необходимое подтягивающему резистору, чтобы вернуть высокий уровень на шине
// Следующий импульс сброса должен посылаться не ранее чем через 480 микросекунд после завершения предыдущего.	
	for (uint8_t i=0; i<65; i++){ // Ждем 15-60 мкс на определение устройства на шине (шина должна притянуться к земле)
		if (!(ONEWIRE_LEVEL)){ // Если шина притянулась к земле извне
			for(reply1wire=1; reply1wire!=0; reply1wire++){ // Ждём, поднимет ли кто-нибудь уровень в течении 255 мкс (от 60 до 240 мкс)
				if(ONEWIRE_LEVEL) // Если шину подняли 
					break; // - устройство присутствует
				_delay_us(1);
			}
			SREG = stektemp; // Вернем значение стека
			sei(); // Разрешим глобальные прерывания
			if (reply1wire) // Если устройство на шине 1-wire присутствует
				return 1; // Инициализация успешна
			else // Если уровень так и не подняли,
				return 0; // то опустило его не устройство. Ошибка на шине 1wire
		}
		_delay_us(1);
	}
	SREG = stektemp; // Вернем значение стека
	sei(); // на случай, если шина не притягивалась к земле
	return 0;
}
//----------------------------------------
void ONE_wire_SendBit(uint8_t bit){ // Отправить 1 бит данных по шине 1-wire
	uint8_t stektemp = SREG; // Сохраним значение стека
	cli(); // Запретим глобальные прерывания
	ONEWIRE_0; // Установить 0 на шине 1-wire
	_delay_us(2); // Задержка как минимум на 2 микросекунды
	if (bit) // Если передаем 1
		ONEWIRE_1; // Установить 1 на шине 1-wire
	_delay_us(63); // Задержка как минимум на 60 микросекунд (63+2=65мкс - с запасом 5мкс)
	ONEWIRE_1; // Установить 1 на шине 1-wire
	_delay_us(2); // Время необходимое подтягивающему резистору, чтобы вернуть высокий уровень на шине
	SREG = stektemp; // Вернем значение стека
	sei(); // Разрешим глобальные прерывания
}
//----------------------------------------
// Поскольку время между передаваемыми битами может длиться до бесконечности, то глобальные прерывания можно не запрещать
void ONE_wire_SendByte(uint8_t c){ // Отправить байт данных по шине 1-wire
	for (uint8_t i=0; i<8; i++){ // Посылаем отдельно каждый из 8 бит на устройство
		ONE_wire_SendBit(c & 1); // Отправить 1 бит данных по шине 1-wire
		c >>= 1; // Сдвинем байт на 1 бит вправо и перезапишем его
	}
}
//----------------------------------------
uint8_t ONE_wire_ReadBit(void){ // Чтение бита данных по шине 1-wire
	uint8_t stektemp = SREG; // Сохраним значение стека
	cli(); // Запретим глобальные прерывания
	ONEWIRE_0; // Установить 0 на шине 1-wire
	_delay_us(2); // Задержка как минимум на 2 микросекунды
	ONEWIRE_1; // Установить 1 на шине 1-wire (отпускаем шину)
	_delay_us(6); // Пауза до момента сэмплирования, всего не более 15 мкс (2+6=8мкс)
	uint8_t bit = ONEWIRE_LEVEL; // Читаем бит
	_delay_us(57); // Ожидание до следующего тайм-слота, минимум 60 мкс с начала низкого уровня
	// 60 + 5мкс для гарантированного установления высокого уровеня на шине - прошедшие 8мкс = 57мкс
	SREG = stektemp; // Вернем значение стека
	sei(); // Разрешим глобальные прерывания
	return bit; // Вернем результат
}
//----------------------------------------
// Поскольку время между принимаемыми битами может длиться до бесконечности, то глобальные прерывания можно не запрещать
uint8_t ONE_wire_ReadByte(void){ // Чтение байта данных по шине 1-wire
	uint8_t c = 0; // Для временного хранения результата
	for (uint8_t i=0; i<8; i++) // 8 бит
		c |= ONE_wire_ReadBit()<<i; // Читаем бит
	return c; // Вернем результат
}
//----------------------------------------