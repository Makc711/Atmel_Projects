/* Основные возможности библиотеки:
 * -# требуется всего 5 линий микроконтроллера
 * -# поддерживается программный или аппаратный SPI
 * -# поддерживаются модули всех типов - 4, 8 или 16 знакомест
 * -# используется минимум ОЗУ
 * 
 * Для компиляции требуется:
 * 	-# WinAVR-20100110 или более новая версия
 */

#ifndef HCMS_297X_H_
#define HCMS_297X_H_

#include "main.h"

// Если для вывода на индикаторы не задействуется аппаратный SPI,
// надо закомментировать этот макрос (время обновления дисплея возрастет в 5 раз)
//#define USE_SPI

// Если курсор не нужен - закомментировать этот макрос.
// Увы, курсор не мигает - просто инверсия знакоместа
//#define USE_CURSOR

#define		CHIP_CNT		4 // Количество независимых индикаторов
#define		CHIP_POS		4 // Количество знакомест на 1 индикаторе
#define 	FONT_COLS		5 // Количество столбцов в знакоместе (менять не следует)

#define		SCR_SIZE		(CHIP_CNT*CHIP_POS) // Количество символов, умещающихся на дисплее
#define		CHIP_RAW_SIZE	(CHIP_CNT*CHIP_POS*FONT_COLS) // Количество байт в массиве знакомест

// Если все линии управления на 1 порту - нужно описать его,
// иначе макрос закомментировать!
#define		PORT_HCMS		D

// Далее идет описание портов и пинов для управления чипом.
// Номер пина - это номер бита в порту, т.е. число от 0 до 7
#define		PORT_CE			PORT_HCMS // Порт выбора кристалла
#define		PIN_CE			6         // Пин выбора кристалла

#define		PORT_RS			PORT_HCMS // Порт выбора регистра
#define		PIN_RS			4         // Пин выбора регистра

#define		PORT_RST		PORT_HCMS // Порт сброса
#define		PIN_RST			7         // Пин сброса

#if !defined(USE_SPI)
// Если НЕ используется аппаратный SPI, следует дополнительно определить
#	define	PORT_CLK		PORT_HCMS // Порт синхронизации
#	define	PIN_CLK			5        // Пин синхронизации

#	define	PORT_DI			PORT_HCMS // Порт последовательного вывода данных
#	define	PIN_DI			3        // Пин последовательного вывода данных
#endif

#define ANIMATE_DELAY_MS	20 // Задержка в миллисекундах при анимированном выводе строк (по умолчанию: 10)

// Константы для управления яркостью
typedef enum{				// Яркость
	PWM_BRIGHT_000	= 0,	// 0.0%
	PWM_BRIGHT_002	= 1,	// 1.7%
	PWM_BRIGHT_003	= 2, 	// 3.3%
	PWM_BRIGHT_005	= 3, 	// 5.0%
	PWM_BRIGHT_007	= 4, 	// 6.7%
	PWM_BRIGHT_008	= 5, 	// 8.3%
	PWM_BRIGHT_012	= 6, 	// 11.7%
	PWM_BRIGHT_015	= 7, 	// 15%
	PWM_BRIGHT_018	= 8, 	// 18%
	PWM_BRIGHT_023	= 9, 	// 23%
	PWM_BRIGHT_030	= 10,	// 30%
	PWM_BRIGHT_037	= 11,	// 37%
	PWM_BRIGHT_047	= 12,	// 47%
	PWM_BRIGHT_060	= 13,	// 60%
	PWM_BRIGHT_080	= 14,	// 80%
	PWM_PRIGHT_100	= 15 	// 100%
} pwm_brightness_t;

#define MIN_BRIGHTNESS		PWM_BRIGHT_002 // Минимально разумная яркость
#define MAX_BRIGHTNESS		PWM_PRIGHT_100 // Максимально допустимая яркость
#define DEFAULT_BRIGHTNESS	PWM_BRIGHT_080 // Яркость по умолчанию

// Константы для управления пиковым током
typedef enum{				// Пиковый ток  Яркость
	PEAK_04_MA		= 2,	//  4.0 mA       31%
	PEAK_06_MA		= 1,	//  6.4 mA       50%
	PEAK_09_MA		= 0,	//  9.3 mA       73%
	PEAK_13_MA		= 3		// 12.8 mA       100%
} peak_current_t;

#define DEFAULT_PEAK_CURRENT	PEAK_09_MA // Пиковый ток по умолчанию

// Структура 0-го регистра управления
typedef	union{
	struct{
		pwm_brightness_t
				brightness		: 4;	// Яркость
		peak_current_t
				peak_current	: 2;	// Пиковый ток
		uint8_t	sleep_mode		: 1;	// Режим сна
		uint8_t reg				: 1;	// Номер регистра (должен быть 0)
	};
	uint8_t		byte;					// Доступ к регистру, как 1 байту
} ctrl_reg0_t;

// Структура 1-го регистра управления
typedef	union{
	struct{
		uint8_t	data_out_ctrl	: 1;	// Последовательный или параллельный режим DOUT
		uint8_t	edo_prescaler	: 1;	// Предделитель внешнего тактовго генератора
		uint8_t	reserved		: 5;	// Не изменять никогда!
		uint8_t	reg				: 1;	// Номер регистра (должен быть 1)
	};
	uint8_t		byte;					// Доступ к регистру, как 1 байту
} ctrl_reg1_t;

// Вспомогательный тип для экономии памяти и кода
#if (CHIP_RAW_SIZE > UINT8_MAX)
#define buf_size_t	uint16_t
#else
#define buf_size_t	uint8_t
#endif

extern char hcms_screen[SCR_SIZE]; // Экранный символьный буфер (SCR_SIZE - количество символов на дисплее)

void hcms_clrscr(void); // Очистка дисплея

#if defined(USE_CURSOR) // Если используется курсор
#define NO_CURSOR	(SCR_SIZE+1) // Макрос скрытия курсора с дисплея
/** Установка позиции курсора
 * Чтобы убрать курсор, надо использовать #NO_CURSOR (пример: hcms_cursor_pos(NO_CURSOR); // Убирает курсор с экрана)
 * @param pos - позиция курсора на дисплее, начиная с 0
 */
void hcms_cursor_pos(uint8_t pos);
#endif

/** Вывод строки на дисплей
 * Всегда выводится не больше символов, чем умещается на дисплее. 
 * Если строка короче, то оставшееся место дисплея очищается.
 * @param s - выводимая строка
 */
void hcms_puts(char *s);

/** Вывод строки из flash на дисплей
 * Символы, не влезающие на дисплей, отбрасываются. 
 * Если строка короткая, то свободное место на дисплее очищается
 * @param s - строка во flash
 */
void hcms_puts_P(const char *s);

/** Обновление дисплея
 * Копирует содержимое экранного буфера на дисплей
 */
void hcms_update_scr(void);

/** Установка яркости дисплея
 * @param br - уровень яркости
 */
void hcms_bright(pwm_brightness_t br);

/** Установка пикового тока сегмента
 * @param pc - уровень пиковго тока
 */
void hcms_peak_current(peak_current_t pc);

/** Включение/отключение дисплея
 * При выключении переводит дисплей в спящий режим.
 * @param on = 0 - выключить, on != 0 - включить дисплей
 * (после команды на выключение и подаче команды на включение, дисплей не просыпается)
 */
void hcms_on(uint8_t on);

#define DOWN  1 // Всплытие строки снизу вверх
#define UP   -1 // Всплытие строки сверху вниз
/** Вывод строки с эффектом всплывания или опускания (только для измениющихся символов)
 * Строка на дисплее заменяется выводимой строкой с эффектом всплывания или
 * погружения символов.
 * Символы сдвигаются на дисплее (один символ вверх, дополняя снизу знакоместо)
 * @param s - новая строка
 * @param up - направление эффекта (DOWN - снизу вверх, UP - сверху вниз)
 */
void hcms_rollower_puts(char *s, int8_t up);

/** Вывод строки с эффектом всплывания или опускания (для ВСЕХ символов строки)
 * Строка на дисплее заменяется выводимой строкой с эффектом всплывания или
 * погружения символов.
 * Символы сдвигаются на дисплее (один символ вверх, дополняя снизу знакоместо)
 * @param s - новая строка
 * @param up - направление эффекта (DOWN - снизу вверх, UP - сверху вниз)
 */
void hcms_rollower_puts_all(char *s, int8_t up);

/** Вывод строки с эффектом сдвига влево
 * Символы сдвигаются влево на дисплее
 * На освободившееся место в последнюю ячейку записывается новый символ
 * @param s - новая строка
 */ 
void hcms_shiftleft_puts(char *s);

/** Вывод строки с эффектом сдвига вправо
 * Символы сдвигаются вправо на дисплее
 * На освободившееся место в первую ячейку записывается новый символ
 * @param s - новая строка
 */ 
void hcms_shiftright_puts(char *s);

/** Вывод строки с эффектом последовательного всплытия или опускания (только для измениющихся символов)
 * В отличие от #hcms_rollover_puts эта функция осуществляет не одновременное
 * всплытие/опускание всех символов строки, а последовательное: каждый
 * следующий символ начинает движение с запаздыванием в одну строку
 * @param s - выводимая строка
 * @param up - направение (0 или более - снизу вверх, иначе - сверху вниз)
 */
void hcms_smooth_rollower_puts(char *s, int8_t up);

/** Вывод строки с эффектом последовательного всплытия или опускания (для ВСЕХ символов строки)
 * В отличие от #hcms_rollover_puts эта функция осуществляет не одновременное
 * всплытие/опускание всех символов строки, а последовательное: каждый
 * следующий символ начинает движение с запаздыванием в одну строку
 * @param s - выводимая строка
 * @param up - направение (0 или более - снизу вверх, иначе - сверху вниз)
 */
void hcms_smooth_rollower_puts_all(char *s, int8_t up);

// Нижний уровень управления дисплеем
/** Вывод данных на дисплей
 * Выводит заданное количество байтов на дисплей.
 * @param buf - указатель на данные
 * @param sz - количество выводимых байтов
 */
void hcms_raw_pixels(uint8_t *buf, buf_size_t sz);

#endif /* HCMS_297X_H_ */
